package org.number_perceptron;

import java.util.Random;

public class SingleLayerPerceptron {
    private double[][] weights; // Веса перцептрона
    private double learningRate; // Коэффициент обучения
    private int outputSize; // Размер выхода (количество классов)

    // Конструктор перцептрона с одним слоем
    // inputSize - количество входов (входных признаков)
    // outputSize - количество выходов (например, количество классов)
    public SingleLayerPerceptron(int inputSize, int outputSize) {

        // Инициализация матрицы весов размером [inputSize][outputSize]
        weights = new double[inputSize][outputSize];

        // Сохраняем количество выходных нейронов
        this.outputSize = outputSize;

        // Устанавливаем значение скорости обучения (learningRate)
        learningRate = 0.1;

        // Вызываем метод для инициализации весов случайными значениями
        initializeWeights();
    }

    // Метод для инициализации весов случайными значениями
    // Каждый вес инициализируется случайным значением от -1 до 1
    private void initializeWeights() {
        Random rand = new Random(); // Генератор случайных чисел

        // Цикл по каждой строке матрицы весов (каждый входной признак)
        for (int i = 0; i < weights.length; i++) {

            // Цикл по каждому столбцу матрицы весов (каждый выходной нейрон)
            for (int j = 0; j < weights[i].length; j++) {

                // Инициализация каждого веса случайным значением от -1 до 1
                weights[i][j] = rand.nextDouble() * 2 - 1;
            }
        }
    }

    // Функция активации (сигмоидная функция)
    // Преобразует входное значение в диапазон от 0 до 1
    // Используется для моделирования вероятности принадлежности к классу
    private double sigmoid(double x) {
        // Формула для сигмоиды: 1 / (1 + exp(-x))
        return 1.0 / (1.0 + Math.exp(-x));
    }

    // Производная сигмоидной функции
    // Используется в процессе обучения для вычисления градиента ошибки
    // x здесь — это уже вычисленное значение сигмоидной функции
    private double sigmoidDerivative(double x) {
        // Формула для производной сигмоиды: x * (1 - x)
        // Это упрощенная версия, где x — это значение сигмоиды
        return x * (1 - x);
    }

    // Обучение перцептрона на наборе данных
   // input - матрица входных данных, где каждая строка представляет один пример
  // output - массив целевых классов (меток) для каждого примера
  // epochs - количество эпох (итераций), за которое перцептрон должен пройти обучение
    public void train(double[][] input, int[] output, int epochs) {

        // Основной цикл обучения, который повторяется заданное количество раз (epochs)
        for (int epoch = 0; epoch < epochs; epoch++) {

            // Матрица для хранения выходов сети для каждого входного примера
            double[][] outputs = new double[input.length][outputSize];

            // Прямое распространение: вычисление выходов на основе текущих весов и входных данных
            // Для каждого примера из обучающего набора данных
            for (int i = 0; i < input.length; i++) {

                // Для каждого выхода (класса), который перцептрон может предсказать
                for (int j = 0; j < outputSize; j++) {

                    double sum = 0; // Суммируем взвешенные входные значения для каждого выхода

                    // Для каждого входного признака (например, пикселя изображения)
                    for (int k = 0; k < input[i].length; k++) {
                        // Умножаем каждый входной признак на соответствующий вес и добавляем к сумме
                        sum += input[i][k] * weights[k][j];
                    }

                    // Применяем сигмоидную функцию активации к сумме, чтобы получить выходное значение
                    outputs[i][j] = sigmoid(sum);
                }
            }

            // Обратное распространение ошибки (обновление весов на основе разницы между реальным и целевым выходом)
            // Для каждого примера обучающего набора
            for (int i = 0; i < input.length; i++) {

                // Получаем целевое значение (метку класса) для текущего примера
                int target = output[i]; // Целевой класс, который нужно предсказать

                // Для каждого возможного выхода (класса)
                for (int j = 0; j < outputSize; j++) {

                    // Ошибка = разница между целевым значением (1 для правильного класса, 0 для остальных)
                    // и фактическим выходом, рассчитанным перцептроном
                    double error = (j == target ? 1 : 0) - outputs[i][j];

                    // Обновление весов для текущего выхода j
                    for (int k = 0; k < input[i].length; k++) {
                        // Производная сигмоидной функции используется для вычисления коррекции весов
                        // Коррекция веса зависит от ошибки, производной сигмоида и значения входного признака
                        weights[k][j] += learningRate * error * sigmoidDerivative(outputs[i][j]) * input[i][k];
                    }
                }
            }
        }
    }

    // Метод для предсказания классов (цифр) на основе входных данных
    // input - матрица входных данных, где каждая строка представляет один пример (вектор признаков)
    public int[] predict(double[][] input) {

        // Массив для хранения предсказанных классов (меток) для каждого входного примера
        int[] predictions = new int[input.length];

        // Цикл по каждому входному примеру
        for (int i = 0; i < input.length; i++) {

            // Массив для хранения выходов нейронной сети для текущего примера
            double[] outputs = new double[outputSize];

            // Цикл по каждому возможному классу (например, 10 классов для цифр от 0 до 9)
            for (int j = 0; j < outputSize; j++) {

                double sum = 0; // Суммируем взвешенные входные значения для каждого выхода

                // Для каждого входного признака
                for (int k = 0; k < input[i].length; k++) {
                    // Умножаем каждый входной признак на соответствующий вес и добавляем к сумме
                    sum += input[i][k] * weights[k][j];
                }

                // Применяем сигмоидную функцию активации к сумме, чтобы получить выходное значение
                outputs[j] = sigmoid(sum);
            }

            // Находим индекс максимального выхода (он соответствует предсказанному классу)
            predictions[i] = getMaxIndex(outputs);
        }

        // Возвращаем массив предсказанных классов для всех входных примеров
        return predictions;
    }

    // Метод для нахождения индекса максимального значения в массиве
    // Используется для определения, какой класс был предсказан (наибольшая вероятность)
    private int getMaxIndex(double[] array) {
        int maxIndex = 0; // Изначально считаем, что максимальное значение на 0 позиции

        // Цикл по элементам массива, начиная с индекса 1
        for (int i = 1; i < array.length; i++) {
            // Если текущий элемент больше, чем значение на позиции maxIndex,
            // обновляем maxIndex на текущий индекс
            if (array[i] > array[maxIndex]) {
                maxIndex = i;
            }
        }

        // Возвращаем индекс максимального значения
        return maxIndex;
    }

    // Основной метод для тестирования
    public static void main(String[] args) {
        // Данные для обучения
        double[][] X_train = {
                {       0, 0, 1, 1, 1, 1, 1, 1, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 1, 1, 1, 1, 1, 1, 0, 0}, // 0

                {       0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0}, // 1

                // Пример для 2, 3, 4, 5, 6, 7, 8, 9
                {       1, 1, 1, 1, 1, 1, 1, 1, 1, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
                        1, 1, 1, 1, 1, 1, 1, 1, 1, 0,
                        1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        1, 1, 1, 1, 1, 1, 1, 1, 1, 0}, // 2

                {       1, 1, 1, 1, 1, 1, 1, 1, 1, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
                        1, 1, 1, 1, 1, 1, 1, 1, 1, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
                        1, 1, 1, 1, 1, 1, 1, 1, 1, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, // 3

                {       0, 0, 1, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 1, 1, 1, 1, 1, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, // 4

                {       0, 0, 1, 1, 1, 1, 1, 1, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 1, 1, 1, 1, 1, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 1, 1, 1, 1, 1, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, // 5

                {       0, 0, 1, 1, 1, 1, 1, 1, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 1, 1, 1, 1, 1, 1, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 1, 1, 1, 1, 1, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, // 6

                {       0, 0, 1, 1, 1, 1, 1, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, // 7

                {       0, 0, 1, 1, 1, 1, 1, 1, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 1, 1, 1, 1, 1, 1, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 1, 1, 1, 1, 1, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, // 8

                {       0, 0, 1, 1, 1, 1, 1, 1, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 1, 1, 1, 1, 1, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 1, 1, 1, 1, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0},  // 9
        };

        int[] y_train = {
                0, // для 0
                1, // для 1
                2, // для 2
                3, // для 3
                4, // для 4
                5, // для 5
                6, // для 6
                7, // для 7
                8, // для 8
                9  // для 9
        };

        // Создание и обучение перцептрона
        SingleLayerPerceptron perceptron = new SingleLayerPerceptron(100, 10);
        perceptron.train(X_train, y_train, 10000);

        // Тестирование
        double[][] Null_test = {
                {       0, 0, 1, 1, 1, 1, 1, 1, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 1, 1, 1, 1, 1, 1, 0, 0}, // 0
        };

        double[][] One_test = {
                {       0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0}, // 1
        };

        double[][] Two_test = {
                {       1, 1, 1, 1, 1, 1, 1, 1, 1, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
                        1, 1, 1, 1, 1, 1, 1, 1, 1, 0,
                        1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        1, 1, 1, 1, 1, 1, 1, 1, 1, 0}, // 2
        };

        double[][] Three_test = {
                {       1, 1, 1, 1, 1, 1, 1, 1, 1, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
                        1, 1, 1, 1, 1, 1, 1, 1, 1, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
                        1, 1, 1, 1, 1, 1, 1, 1, 1, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, // 3
        };

        double[][] Four_test = {
                {       0, 0, 1, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 1, 1, 1, 1, 1, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, // 4
        };

        double[][] Five_test = {
                {       0, 0, 1, 1, 1, 1, 1, 1, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 1, 1, 1, 1, 1, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 1, 1, 1, 1, 1, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, // 5
        };

        double[][] Six_test = {
                {       0, 0, 1, 1, 1, 1, 1, 1, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 1, 1, 1, 1, 1, 1, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 1, 1, 1, 1, 1, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, // 6
        };

        double[][] Seven_test = {
                {       0, 0, 1, 1, 1, 1, 1, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, // 7
        };

        double[][] Eight_test = {
                {       0, 0, 1, 1, 1, 1, 1, 1, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 1, 1, 1, 1, 1, 1, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 1, 1, 1, 1, 1, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, // 8
        };

        double[][] Nine_test = {
                {       0, 0, 1, 1, 1, 1, 1, 1, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 1, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 1, 1, 1, 1, 1, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                        0, 0, 0, 1, 1, 1, 1, 1, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0},  // 9
        };

        // Тестирование на распознавание нуля
        int[] predictions_0 = perceptron.predict(Null_test);
        for (int prediction : predictions_0) {
            System.out.println("Цифра: " + prediction);
        }

        // Тестирование на распознавание единицы
        int[] predictions_1 = perceptron.predict(One_test);
        for (int prediction : predictions_1) {
            System.out.println("Цифра: " + prediction);
        }

        // Тестирование на распознавание четвёрки
        int[] predictions_4 = perceptron.predict(Four_test);
        for (int prediction : predictions_4) {
            System.out.println("Цифра: " + prediction);
        }

        // Тестирование на распознавание двойки
        int[] predictions_2 = perceptron.predict(Two_test);
        for (int prediction : predictions_2) {
            System.out.println("Цифра: " + prediction);
        }

        // Тестирование на распознавание тройки
        int[] predictions_3 = perceptron.predict(Three_test);
        for (int prediction : predictions_3) {
            System.out.println("Цифра: " + prediction);
        }

        // Тестирование на распознавание шестёрки
        int[] predictions_6 = perceptron.predict(Six_test);
        for (int prediction : predictions_6) {
            System.out.println("Цифра: " + prediction);
        }

        // Тестирование на распознавание пятёрки
        int[] predictions_5 = perceptron.predict(Five_test);
        for (int prediction : predictions_5) {
            System.out.println("Цифра: " + prediction);
        }

        // Тестирование на распознавание семёрки
        int[] predictions_7 = perceptron.predict(Seven_test);
        for (int prediction : predictions_7) {
            System.out.println("Цифра: " + prediction);
        }

        // Тестирование на распознавание девятки
        int[] predictions_9 = perceptron.predict(Nine_test);
        for (int prediction : predictions_9) {
            System.out.println("Цифра: " + prediction);
        }

        // Тестирование на распознавание восьмёрки
        int[] predictions_8 = perceptron.predict(Eight_test);
        for (int prediction : predictions_8) {
            System.out.println("Цифра: " + prediction);
        }

    }
}


